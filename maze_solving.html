<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Maze Solving</title>
    <style>

    </style>
</head>

<body>
    <div style="float: left; width: 25%; margin: 5px;">
        <div id="tileDiv">
            <fieldset>
                <legend>Maze</legend>



                <input type="radio" id="startRadio" name="mazeMode" value="start" checked onchange="selectMazeMode('start');" />
                <label for="blockRadio">Start Point</label>
                </br>

                <input type="radio" id="destRadio" name="mazeMode" value="destination" onchange="selectMazeMode('destination');" />
                <label for="blockRadio">Destination Point</label>
                </br>

                <input type="radio" id="wall_cellRadio" name="mazeMode" value="wall_cell" onchange="selectMazeMode('wall_cell');" />
                <label for="blockRadio">Wall - cell</label>
                </br>

                <input type="radio" id="wall_rowRadio" name="mazeMode" value="wall_row" onchange="selectMazeMode('wall_row');" />
                <label for="blockRadio">Wall - row</label>
                </br>

                <input type="radio" id="wall_colRadio" name="mazeMode" value="wall_col" onchange="selectMazeMode('wall_col');" />
                <label for="blockRadio">Wall - column</label>
                </br>

                <input type="button" value="Generate Random Maze" />
                </br>

                <input type="button" value="Clear Maze" onclick="createMaze();" />



            </fieldset>

        </div>
        </br>
        <div id="solvingAlgorithmsDiv">
            <fieldset>
                <legend>Solving Algorithms</legend>
                <label for="bfsRadio">BFS</label>
                <input type="radio" id="bfsRadio" name="solvingAlgorithms" value="bfs" checked />
                <label for="dfsRadio">DFS</label>
                <input type="radio" id="dfsRadio" name="solvingAlgorithms" value="dfs" />
                </br>
                <input type="button" value="Find Path" onclick="preparePathFinding();" />

            </fieldset>
        </div>
    </div>
    </br>

    <canvas id="canvas" width="500" height="500" style="border: solid 1px black"></canvas>
    <p id="queueMsg"></p>
    <script>

        function Cell(status) {
            this.status = status;
            this.parent = undefined;
        }
        /*
         0: empty
         1: block
         2: start
         3: destination
         4: ongoing
         5: found
        */
        var canvas = document.getElementById("canvas");
        var ctx = canvas.getContext("2d");

        var selectedMode = 'start';

        var grid;
        var rows = 20;
        var cols = 20;
        var cellSize = 25;

        var mousePosition = {
            x: 0,
            y: 0,
        }

        createMaze();


        function createMaze() {
            grid = [];
            for (var i = 0; i < rows; i++) {
                var temp = [];
                for (var j = 0; j < cols; j++) {
                    var cell = new Cell(0);
                    temp.push(cell);
                }
                grid.push(temp);
            }


            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    ctx.strokeRect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }

        }

        function selectMazeMode(mode) {
            selectedMode = mode;
        }


        canvas.addEventListener('mousemove', function (e) {
            var bbox = canvas.getBoundingClientRect();
            var x = e.clientX - bbox.left;
            var y = e.clientY - bbox.top;

            mousePosition.x = x;
            mousePosition.y = y;

        });

        canvas.addEventListener('click', function (e) {

            var x = mousePosition.x;
            var y = mousePosition.y;

            var col = Math.floor(x / cellSize);
            var row = Math.floor(y / cellSize);

            var cell = grid[row][col];

            switch (selectedMode) {
                case 'start':
                    setStartPoint(row, col);
                    break;
                case 'destination':
                    setDestinationPoint(row, col);
                    break;
                case 'wall_cell':
                    if (grid[row][col].status == 1) {
                        removeWall(row, col);
                    } else {
                        createWall(row, col);
                    }
                    break;
                case 'wall_row':
                    if (grid[row][col].status == 1) {
                        for (var i = 0; i < cols; i++) {
                            removeWall(row, i)
                        }
                    } else {
                        for (var i = 0; i < cols; i++) {
                            createWall(row, i);
                        }
                    }
                    break;
                case 'wall_col':
                    if (grid[row][col].status == 1) {
                        for (var i = 0; i < rows; i++) {
                            removeWall(i, col)
                        }
                    } else {
                        for (var i = 0; i < rows; i++) {
                            createWall(i, col);
                        }
                    }
                    break;
            }
        });


        function createWall(row, col) {

            grid[row][col].status = 1;
            ctx.fillStyle = '#ccc';
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
            ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
        }

        function removeWall(row, col) {
            grid[row][col].status = 0;
            ctx.fillStyle = '#fff';
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
            ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
        }

        function setStartPoint(row, col) {

            var oldRow;
            var oldCol;

            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    if (grid[i][j].status == 2) {
                        oldRow = i;
                        oldCol = j;
                        grid[i][j].status = 0;
                    }
                }
            }

            ctx.fillStyle = '#fff';
            ctx.fillRect(oldCol * cellSize, oldRow * cellSize, cellSize, cellSize);
            ctx.strokeRect(oldCol * cellSize, oldRow * cellSize, cellSize, cellSize);

            grid[row][col].status = 2;
            ctx.fillStyle = 'green';
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
            ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
        }

        function setDestinationPoint(row, col) {
            var oldRow;
            var oldCol;

            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    if (grid[i][j].status == 3) {
                        oldRow = i;
                        oldCol = j;
                        grid[i][j].status = 0;
                    }
                }
            }

            ctx.fillStyle = '#fff';
            ctx.fillRect(oldCol * cellSize, oldRow * cellSize, cellSize, cellSize);
            ctx.strokeRect(oldCol * cellSize, oldRow * cellSize, cellSize, cellSize);

            grid[row][col].status = 3;
            ctx.fillStyle = 'red';
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
            ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
        }

        function selectMode(input) {
            mode = input.value;
        }


        function preparePathFinding() {
            var checkStartPoint = false;

            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    if (grid[i][j].status == 2) {
                        checkStartPoint = true;
                        break;
                    }
                }
            }

            if (!checkStartPoint) {
                alert("Please set up start point");
                return;
            }

            var checkDestinationPoint = false;

            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    if (grid[i][j].status == 3) {
                        checkDestinationPoint = true;
                        break;
                    }
                }
            }

            if (!checkDestinationPoint) {
                alert("Please set up destination point");
                return;
            }

            var solvingAlgorithms = document.getElementsByName("solvingAlgorithms");
            var selectedAlgorithm;
            for (var i = 0; i < solvingAlgorithms.length; i++) {
                if (solvingAlgorithms[i].checked) {
                    selectedAlgorithm = solvingAlgorithms[i].value;
                    break;
                }
            }

            switch (selectedAlgorithm) {
                case 'bfs':
                    console.log("bfs");
                    findBFSPath();
                    break;
                case 'dfs':
                    console.log("dfs");
                    findDFSPath();
                    break;
            }


        }

        function findDFSPath() {
            var startPoint, destinationPoint;

            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    if (grid[i][j].status == 2) {
                        startPoint = {
                            row: i,
                            col: j
                        }
                        break;
                    }

                }
            }


            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    if (grid[i][j].status == 3) {
                        destinationPoint = {
                            row: i,
                            col: j
                        }
                        break;
                    }
                }
            }


            var stack = [startPoint];


            var timer = setInterval(function () {

                var row = stack[stack.length - 1].row;
                var col = stack[stack.length - 1].col;
                stack.pop();

                if (row == destinationPoint.row && col == destinationPoint.col) {
                    alert("target found!");
                    clearInterval(timer);
                    tracePath(row, col);
                    return;
                }

                if (row == startPoint.row && col == startPoint.col) {

                } else {
                    ctx.fillStyle = "blue";
                    ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
                }

                

                

                

                if (col + 1 < cols) {
                    if (grid[row][col + 1].status == 0 || grid[row][col + 1].status == 3) {
                        if (!checkDuplicate(row, col + 1, stack)) {
                            stack.push({ row: row, col: col + 1 });
                            grid[row][col + 1].status = 4;
                            grid[row][col + 1].parent = { row: row, col: col };

                            //console.log("push", row, col + 1);
                        }
                    }
                }

                 if (col - 1 >= 0) {
                    if (grid[row][col - 1].status == 0 || grid[row][col - 1].status == 3) {
                        if (!checkDuplicate(row, col - 1, stack)) {
                            stack.push({ row: row, col: col - 1 });
                            grid[row][col - 1].status = 4;
                            grid[row][col - 1].parent = { row: row, col: col };

                            //console.log("push", row, col -1);
                        }
                    }

                }

                 if (row + 1 < rows) {
                    if (grid[row + 1][col].status == 0 || grid[row + 1][col].status == 3) {
                        if (!checkDuplicate(row + 1, col, stack)) {
                            stack.push({ row: row + 1, col: col });
                            grid[row + 1][col].status = 4;
                            grid[row + 1][col].parent = { row: row, col: col };

                            //console.log("push", row + 1, col);
                        }
                    }

                }

                 if (row - 1 >= 0) {
                    if (grid[row - 1][col].status == 0 || grid[row - 1][col].status == 3) {
                        if (!checkDuplicate(row - 1, col, stack)) {
                            stack.push({ row: row - 1, col: col });
                            grid[row - 1][col].status = 4;
                            grid[row - 1][col].parent = { row: row, col: col };

                            //console.log("push", row-1, col);
                        }
                    }
                }

                var str = "";
                for (var i = 0; i < stack.length; i++) {
                    str += "(" + stack[i].row + ", " + stack[i].col + ") "
                }

                var queueMsg = document.getElementById("queueMsg");
                queueMsg.textContent = str;

                if (stack.length == 0) {
                    alert("Target can't be found!")
                    clearInterval(timer);

                    return;
                }
            }, 500);
        }

        function findBFSPath() {

            var startPoint, destinationPoint;

            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    if (grid[i][j].status == 2) {
                        startPoint = {
                            row: i,
                            col: j
                        }
                        break;
                    }

                }
            }


            for (var i = 0; i < rows; i++) {
                for (var j = 0; j < cols; j++) {
                    if (grid[i][j].status == 3) {
                        destinationPoint = {
                            row: i,
                            col: j
                        }
                        break;
                    }
                }
            }


            var queue = [startPoint];


            var timer = setInterval(function () {

                var row = queue[0].row;
                var col = queue[0].col;
                queue.shift();

                if (row == destinationPoint.row && col == destinationPoint.col) {
                    alert("target found!");
                    clearInterval(timer);
                    tracePath(row, col);
                    return;
                }

                if (row == startPoint.row && col == startPoint.col) {

                } else {
                    ctx.fillStyle = "blue";
                    ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);
                }

                moveCursor(row, col, queue);

                var str = "";
                for (var i = 0; i < queue.length; i++) {
                    str += "(" + queue[i].row + ", " + queue[i].col + ") "
                }

                var queueMsg = document.getElementById("queueMsg");
                queueMsg.textContent = str;

                if (queue.length == 0) {
                    alert("Target can't be found!")
                    clearInterval(timer);

                    return;
                }
            }, 200);

        }

        function tracePath(row, col) {
            parentRow = grid[row][col].parent.row;
            parentCol = grid[row][col].parent.col;

            row = parentRow;
            col = parentCol;

            while (true) {
                if (grid[row][col].status == 2) {
                    break;
                }

                grid[row][col].status = 5;
                ctx.fillStyle = 'cyan';
                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                ctx.strokeRect(col * cellSize, row * cellSize, cellSize, cellSize);

                parentRow = grid[row][col].parent.row;
                parentCol = grid[row][col].parent.col;

                row = parentRow;
                col = parentCol;

            }

        }

        function moveCursor(row, col, list) {

            //console.log(row, col);

            if (row - 1 >= 0) {
                if (grid[row - 1][col].status == 0 || grid[row - 1][col].status == 3) {
                    if (!checkDuplicate(row - 1, col, list)) {
                        list.push({ row: row - 1, col: col });
                        grid[row - 1][col].status = 4;
                        grid[row - 1][col].parent = { row: row, col: col };

                        //console.log("push", row-1, col);
                    }
                }
            }

            if (col - 1 >= 0) {
                if (grid[row][col - 1].status == 0 || grid[row][col - 1].status == 3) {
                    if (!checkDuplicate(row, col - 1, list)) {
                        list.push({ row: row, col: col - 1 });
                        grid[row][col - 1].status = 4;
                        grid[row][col - 1].parent = { row: row, col: col };

                        //console.log("push", row, col -1);
                    }
                }

            }

            if (row + 1 < rows) {
                if (grid[row + 1][col].status == 0 || grid[row + 1][col].status == 3) {
                    if (!checkDuplicate(row + 1, col, list)) {
                        list.push({ row: row + 1, col: col });
                        grid[row + 1][col].status = 4;
                        grid[row + 1][col].parent = { row: row, col: col };

                        //console.log("push", row + 1, col);
                    }
                }

            }

            if (col + 1 < cols) {
                if (grid[row][col + 1].status == 0 || grid[row][col + 1].status == 3) {
                    if (!checkDuplicate(row, col + 1, list)) {
                        list.push({ row: row, col: col + 1 });
                        grid[row][col + 1].status = 4;
                        grid[row][col + 1].parent = { row: row, col: col };

                        //console.log("push", row, col + 1);
                    }
                }
            }
        }

        function checkDuplicate(row, col, list) {
            for (var i = 0; i < list.length; i++) {
                if (list[i].row == row && list[i].col == col) {
                    return true;
                }
            }

            return false;

        }


    </script>
</body>

</html>